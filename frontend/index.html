<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Life Story Voice Journal</title>
    <style>
      :root {
        --bg: #0f0f0f;
        --panel: #171717;
        --muted: #bbbbbb;
        --accent: #5b8def;
        --accent-2: #6dd8b5;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: var(--bg);
        color: #eee;
        padding: 30px;
        max-width: 1100px;
        margin: 0 auto;
      }
      h1 {
        margin-top: 0;
        letter-spacing: 0.5px;
      }
      h2 {
        margin: 0 0 10px;
      }
      p {
        color: var(--muted);
      }
      button {
        padding: 10px 18px;
        background: #2a2a2a;
        color: #fff;
        font-size: 16px;
        cursor: pointer;
        border: 1px solid #333;
        border-radius: 6px;
        margin-top: 10px;
        margin-right: 10px;
      }
      button.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #0b1221;
        font-weight: 600;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: default;
      }
      .tabs {
        display: flex;
        gap: 10px;
        margin: 20px 0;
      }
      .tab-btn {
        padding: 12px 20px;
        border-radius: 10px;
        border: 1px solid #222;
        background: #161616;
        color: #ddd;
      }
      .tab-btn.active {
        background: linear-gradient(135deg, #22304c, #1e283a);
        border-color: #2e3d5b;
        color: #fff;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .panel {
        background: var(--panel);
        border: 1px solid #1f1f1f;
        border-radius: 10px;
        padding: 18px;
        margin-bottom: 16px;
      }
      #log {
        white-space: pre-wrap;
        margin-top: 12px;
        font-size: 14px;
        background: #0f1218;
        padding: 15px;
        border-radius: 6px;
        max-height: 280px;
        overflow-y: auto;
        border: 1px solid #1b2335;
      }
      #status {
        margin-top: 8px;
        font-style: italic;
        color: var(--muted);
      }
      .grid {
        display: grid;
        gap: 12px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      th, td {
        padding: 10px 8px;
        border-bottom: 1px solid #1f1f1f;
        text-align: left;
        vertical-align: top;
      }
      th {
        color: #a6b7d3;
        font-weight: 600;
        letter-spacing: 0.3px;
      }
      tr:hover {
        background: #141822;
      }
      .chip {
        display: inline-block;
        padding: 4px 8px;
        margin: 0 6px 6px 0;
        border-radius: 999px;
        background: #1d2433;
        color: #dfe8ff;
        font-size: 12px;
        border: 1px solid #253149;
      }
      .chip.muted {
        background: #1a1a1a;
        color: var(--muted);
        border: 1px solid #222;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        margin: 0 6px 6px 0;
        border-radius: 10px;
        background: #142238;
        color: #eaf1ff;
        font-size: 12px;
        border: 1px solid #1f2c44;
      }
      .badge .score {
        color: #8ed1c2;
        font-weight: 600;
      }
      .muted {
        color: var(--muted);
        font-size: 14px;
      }
      .chart {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 10px;
      }
      .bar-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .bar-label {
        width: 110px;
        color: var(--muted);
        font-size: 13px;
      }
      .bar-track {
        flex: 1;
        height: 14px;
        background: #1b1b1b;
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid #222;
      }
      .bar-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
      }
      textarea {
        width: 100%;
        min-height: 90px;
        background: #121212;
        color: #eee;
        border: 1px solid #222;
        border-radius: 8px;
        padding: 10px;
        font-size: 15px;
      }
      .answer-box {
        background: #0f1218;
        border: 1px solid #1f2a40;
        border-radius: 10px;
        padding: 14px;
        margin-top: 10px;
        line-height: 1.5;
      }
      .hidden {
        display: none;
      }
      .used-entries {
        margin-top: 10px;
        padding: 10px;
        border: 1px dashed #2b3a55;
        border-radius: 8px;
        background: #0f141f;
      }
      .used-entry {
        margin-bottom: 8px;
      }
      .used-entry time {
        color: var(--muted);
        font-size: 12px;
      }
      .chat-pane {
        background: #0f1218;
        border: 1px solid #1f2437;
        border-radius: 10px;
        padding: 12px;
        max-height: 340px;
        overflow-y: auto;
      }
      .bubble {
        max-width: 80%;
        padding: 10px 12px;
        border-radius: 12px;
        margin: 8px 0;
        line-height: 1.4;
      }
      .bubble.user {
        background: #203459;
        margin-left: auto;
        color: #e8f1ff;
      }
      .bubble.assistant {
        background: #1a1a1a;
        border: 1px solid #222;
        color: #e4e4e4;
      }
      .bubble-meta {
        font-size: 12px;
        color: var(--muted);
        margin-top: 4px;
      }
      .chat-input {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      .chat-input textarea {
        flex: 1;
        min-height: 60px;
      }
    </style>
  </head>

  <body>
    <h1>Life Story Voice Assistant</h1>
    <p>
      Capture new memories or explore insights from what you've already shared.
    </p>

    <div class="tabs">
      <button class="tab-btn active" data-tab="capture">Capture</button>
      <button class="tab-btn" data-tab="insights">Insights &amp; Q&amp;A</button>
    </div>

    <section id="capture" class="tab-content active">
      <div class="panel">
        <h2>Record / Upload entry</h2>
        <p class="muted">
          Click <strong>Start Recording</strong>, tell a story, then click
          <strong>Stop &amp; Save</strong>. Audio is transcribed, analyzed, and stored.
        </p>
        <button id="startBtn" class="primary">ðŸŽ¤ Start Recording</button>
        <button id="stopBtn" disabled>ðŸ›‘ Stop &amp; Save</button>
        <div id="status">Not recording.</div>
        <div id="log"></div>
      </div>
    </section>

    <section id="insights" class="tab-content">
      <div class="panel">
        <h2>Your Entries</h2>
        <div class="muted" id="entriesStatus">Loading entriesâ€¦</div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Summary</th>
                <th>Emotions</th>
                <th>Topics</th>
                <th>People / Places</th>
                <th>Words</th>
              </tr>
            </thead>
            <tbody id="entriesBody"></tbody>
          </table>
        </div>
      </div>

      <div class="panel">
        <h2>Analytics</h2>
        <div class="muted" id="summaryText">Loading statsâ€¦</div>
        <div id="entriesChart" class="chart"></div>
      </div>

      <div class="panel">
        <h2>Ask a Question</h2>
        <p class="muted">Ask anything you'd like to know based on your stored entries.</p>
        <textarea id="questionInput" placeholder="What did I talk about last weekend?"></textarea>
        <button id="askBtn" class="primary">Ask</button>
        <div class="muted" id="askStatus"></div>
        <div id="answerBox" class="answer-box hidden"></div>
        <div id="answerMeta" class="muted hidden"></div>
        <div id="usedEntries" class="used-entries hidden"></div>
      </div>

      <div class="panel">
        <h2>Conversation</h2>
        <p class="muted">Chat with your stored memories. Follow-ups reuse the conversation history.</p>
        <div id="chatPane" class="chat-pane"></div>
        <div class="chat-input">
          <textarea id="chatInput" placeholder="Ask a follow-up..."></textarea>
          <button id="chatSendBtn" class="primary">Send</button>
        </div>
        <div class="muted" id="chatStatus"></div>
      </div>
    </section>

    <script>
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");

      const entriesBody = document.getElementById("entriesBody");
      const entriesStatus = document.getElementById("entriesStatus");
      const summaryText = document.getElementById("summaryText");
      const entriesChart = document.getElementById("entriesChart");
      const questionInput = document.getElementById("questionInput");
      const askBtn = document.getElementById("askBtn");
      const askStatus = document.getElementById("askStatus");
      const answerBox = document.getElementById("answerBox");
      const answerMeta = document.getElementById("answerMeta");
      const usedEntries = document.getElementById("usedEntries");
      const chatPane = document.getElementById("chatPane");
      const chatInput = document.getElementById("chatInput");
      const chatSendBtn = document.getElementById("chatSendBtn");
      const chatStatus = document.getElementById("chatStatus");

      let mediaRecorder = null;
      let chunks = [];
      let insightsLoadedOnce = false;
      let conversationHistory = [];

      // --- Capture tab logic (existing flow) ---
      function log(msg) {
        const time = new Date().toLocaleTimeString();
        logEl.textContent += `[${time}] ${msg}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          chunks = [];

          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };

          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: "audio/webm" });

            log("Recording stopped. Uploading entry to backendâ€¦");
            statusEl.textContent = "Uploading and processing entryâ€¦";

            const formData = new FormData();
            formData.append("file", blob, "entry.webm");

            try {
              const resp = await fetch("http://localhost:8000/entries", {
                method: "POST",
                body: formData,
              });

              if (!resp.ok) {
                const text = await resp.text();
                log(`âŒ Server error: ${resp.status} â€“ ${text}`);
                statusEl.textContent = "Error uploading entry.";
                return;
              }

              const data = await resp.json();
              log("âœ… Entry stored. ID: " + data.entry_id);
              if (data.analysis) {
                log("Summary: " + (data.analysis.summary || "[none]"));
                if (data.analysis.themes) {
                  log("Themes: " + JSON.stringify(data.analysis.themes));
                }
                if (data.analysis.emotions) {
                  log("Emotions: " + JSON.stringify(data.analysis.emotions));
                }
              }

              statusEl.textContent = "Entry saved successfully.";
              insightsLoadedOnce = false; // refresh insights next time tab opens
            } catch (err) {
              console.error(err);
              log("âŒ Failed to upload entry: " + err.message);
              statusEl.textContent = "Upload failed.";
            }
          };

          mediaRecorder.start();
          statusEl.textContent = "Recordingâ€¦ tell your story.";
          log("ðŸŽ™ Recording started.");

          startBtn.disabled = true;
          stopBtn.disabled = false;
        } catch (err) {
          console.error(err);
          log("âŒ Could not start recording: " + err.message);
          statusEl.textContent = "Microphone access failed.";
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      }

      startBtn.addEventListener("click", startRecording);
      stopBtn.addEventListener("click", stopRecording);

      // --- Tabs ---
      const tabButtons = document.querySelectorAll(".tab-btn");
      const tabContents = document.querySelectorAll(".tab-content");

      function setActiveTab(tabName) {
        tabButtons.forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.tab === tabName);
        });
        tabContents.forEach((section) => {
          section.classList.toggle("active", section.id === tabName);
        });

        if (tabName === "insights") {
          loadInsights();
        }
      }

      tabButtons.forEach((btn) => {
        btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
      });

      // --- Insights tab logic ---
      async function loadInsights() {
        if (insightsLoadedOnce) {
          return;
        }
        insightsLoadedOnce = true;
        await Promise.all([fetchEntries(), fetchSummary()]);
      }

      async function fetchEntries() {
        entriesStatus.textContent = "Loading entriesâ€¦";
        entriesBody.innerHTML = "";
        try {
          const resp = await fetch("http://localhost:8000/insights/entries");
          if (!resp.ok) {
            throw new Error(`Server responded with ${resp.status}`);
          }
          const data = await resp.json();
          renderEntries(data);
        } catch (err) {
          entriesStatus.textContent = `Failed to load entries: ${err.message}`;
        }
      }

      function renderEntries(entries) {
        entriesBody.innerHTML = "";
        if (!entries || entries.length === 0) {
          entriesStatus.textContent = "No entries yet.";
          return;
        }
        entriesStatus.textContent = "";

        entries.forEach((entry) => {
          const tr = document.createElement("tr");

          const dateTd = document.createElement("td");
          dateTd.textContent = new Date(entry.created_at).toLocaleString();

          const summaryTd = document.createElement("td");
          summaryTd.innerHTML = `<div>${entry.summary || entry.preview || "â€”"}</div>`;

          const emotionsTd = document.createElement("td");
          emotionsTd.appendChild(renderEmotions(entry));

          const topicsTd = document.createElement("td");
          topicsTd.appendChild(renderChips(entry.topics, "muted", "No topics"));

          const entitiesTd = document.createElement("td");
          const people = renderChips(entry.people, "", "No people");
          const places = renderChips(entry.places, "muted", "No places");
          entitiesTd.appendChild(people);
          entitiesTd.appendChild(places);

          const wordsTd = document.createElement("td");
          wordsTd.textContent = entry.word_count ?? "-";

          tr.appendChild(dateTd);
          tr.appendChild(summaryTd);
          tr.appendChild(emotionsTd);
          tr.appendChild(topicsTd);
          tr.appendChild(entitiesTd);
          tr.appendChild(wordsTd);
          entriesBody.appendChild(tr);
        });
      }

      async function fetchSummary() {
        summaryText.textContent = "Loading statsâ€¦";
        entriesChart.innerHTML = "";
        try {
          const resp = await fetch("http://localhost:8000/insights/summary");
          if (!resp.ok) {
            throw new Error(`Server responded with ${resp.status}`);
          }
          const data = await resp.json();
          renderSummary(data);
        } catch (err) {
          summaryText.textContent = `Failed to load stats: ${err.message}`;
        }
      }

      function renderSummary(data) {
        if (!data) {
          summaryText.textContent = "No data available.";
          return;
        }

        const { total_entries, total_words, average_word_count, entries_per_day, top_emotions, top_topics, top_people, top_places } = data;
        summaryText.textContent = `You've created ${total_entries} entries with ${total_words} total words (avg ${average_word_count.toFixed(1)} words/entry).`;

        const metaWrap = document.createElement("div");
        metaWrap.style.marginTop = "8px";
        metaWrap.appendChild(makeMetaRow("Top emotions", top_emotions));
        metaWrap.appendChild(makeMetaRow("Top topics", top_topics));
        metaWrap.appendChild(makeMetaRow("People", top_people));
        metaWrap.appendChild(makeMetaRow("Places", top_places));

        entriesChart.innerHTML = "";
        entriesChart.appendChild(metaWrap);
        if (!entries_per_day || entries_per_day.length === 0) {
          const empty = document.createElement("div");
          empty.className = "muted";
          empty.textContent = "No entries per-day data yet.";
          entriesChart.appendChild(empty);
          return;
        }

        const maxCount = Math.max(...entries_per_day.map((d) => d.count));

        entries_per_day.forEach((item) => {
          const row = document.createElement("div");
          row.className = "bar-row";

          const label = document.createElement("div");
          label.className = "bar-label";
          label.textContent = item.date;

          const track = document.createElement("div");
          track.className = "bar-track";

          const fill = document.createElement("div");
          fill.className = "bar-fill";
          const percentage = maxCount ? (item.count / maxCount) * 100 : 0;
          fill.style.width = `${Math.max(8, percentage)}%`;
          track.appendChild(fill);

          const count = document.createElement("div");
          count.className = "bar-label";
          count.style.width = "40px";
          count.textContent = item.count;

          row.appendChild(label);
          row.appendChild(track);
          row.appendChild(count);
          entriesChart.appendChild(row);
        });
      }

      function renderEmotions(entry) {
        const container = document.createElement("div");
        const scores = entry.emotion_scores || {};
        const names = Object.keys(scores);

        if (names.length === 0 && (!entry.emotions || entry.emotions.length === 0)) {
          container.textContent = "â€”";
          container.className = "muted";
          return container;
        }

        const sorted = names
          .map((name) => ({ name, score: scores[name] }))
          .sort((a, b) => (b.score || 0) - (a.score || 0))
          .slice(0, 3);

        sorted.forEach(({ name, score }) => {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.innerHTML = `<span>${name}</span><span class="score">${Math.round(score * 100)}%</span>`;
          container.appendChild(badge);
        });

        if (sorted.length === 0 && entry.emotions) {
          entry.emotions.slice(0, 3).forEach((name) => {
            const badge = document.createElement("span");
            badge.className = "chip";
            badge.textContent = name;
            container.appendChild(badge);
          });
        }
        return container;
      }

      function renderChips(items, extraClass = "", emptyText = "") {
        const wrap = document.createElement("div");
        if (!items || items.length === 0) {
          if (emptyText) {
            const chip = document.createElement("span");
            chip.className = `chip ${extraClass} muted`.trim();
            chip.textContent = emptyText;
            wrap.appendChild(chip);
          }
          return wrap;
        }
        items.forEach((item) => {
          const chip = document.createElement("span");
          chip.className = `chip ${extraClass}`.trim();
          chip.textContent = item;
          wrap.appendChild(chip);
        });
        return wrap;
      }

      function makeMetaRow(labelText, items) {
        const row = document.createElement("div");
        row.style.marginBottom = "6px";
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "10px";

        const label = document.createElement("div");
        label.className = "muted";
        label.textContent = `${labelText}:`;

        const content = document.createElement("div");
        content.appendChild(renderChips(items, "", "â€”"));

        row.appendChild(label);
        row.appendChild(content);
        return row;
      }

      function renderUsedEntries(entries) {
        usedEntries.innerHTML = "";
        usedEntries.classList.remove("hidden");
        entries.forEach((entry) => {
          const div = document.createElement("div");
          div.className = "used-entry";
          const dateStr = new Date(entry.created_at).toLocaleString();
          div.innerHTML = `<time>${dateStr}</time><div>${entry.preview || ""}</div>`;
          usedEntries.appendChild(div);
        });
      }

      async function sendConversationMessage() {
        const text = chatInput.value.trim();
        if (!text) {
          chatStatus.textContent = "Please enter a message.";
          return;
        }
        chatStatus.textContent = "Thinkingâ€¦";
        chatSendBtn.disabled = true;

        // Push user message locally
        conversationHistory.push({ role: "user", content: text });
        renderConversation();
        chatInput.value = "";

        try {
          const resp = await fetch("http://localhost:8000/conversation/respond", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message: text,
              history: conversationHistory.map(({ role, content }) => ({ role, content })),
            }),
          });

          if (!resp.ok) {
            const errText = await resp.text();
            throw new Error(errText || `Server responded with ${resp.status}`);
          }

          const data = await resp.json();
          conversationHistory.push({
            role: "assistant",
            content: data.response || "No response.",
            used_entry_ids: data.used_entry_ids || [],
          });
          renderConversation();
          chatStatus.textContent = data.used_entry_ids?.length
            ? `Based on ${data.used_entry_ids.length} past entr${data.used_entry_ids.length === 1 ? "y" : "ies"}.`
            : "";
        } catch (err) {
          chatStatus.textContent = `Error: ${err.message}`;
        } finally {
          chatSendBtn.disabled = false;
        }
      }

      function renderConversation() {
        chatPane.innerHTML = "";
        conversationHistory.forEach((turn) => {
          const bubble = document.createElement("div");
          bubble.className = `bubble ${turn.role}`;
          bubble.textContent = turn.content;
          chatPane.appendChild(bubble);

          if (turn.role === "assistant" && turn.used_entry_ids && turn.used_entry_ids.length) {
            const meta = document.createElement("div");
            meta.className = "bubble-meta";
            meta.textContent = `Referenced entries: ${turn.used_entry_ids.join(", ")}`;
            chatPane.appendChild(meta);
          }
        });
        chatPane.scrollTop = chatPane.scrollHeight;
      }

      async function askQuestion() {
        const question = questionInput.value.trim();
        if (!question) {
          askStatus.textContent = "Please enter a question.";
          return;
        }

        askStatus.textContent = "Thinkingâ€¦";
        askBtn.disabled = true;
        answerBox.classList.add("hidden");
        answerMeta.classList.add("hidden");
        usedEntries.classList.add("hidden");
        usedEntries.innerHTML = "";

        try {
          const resp = await fetch("http://localhost:8000/insights/query", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ question }),
          });

          if (!resp.ok) {
            const text = await resp.text();
            throw new Error(text || `Server responded with ${resp.status}`);
          }

          const data = await resp.json();
          answerBox.textContent = data.answer || "No answer returned.";
          answerBox.classList.remove("hidden");
          const usedCount = data.used_entry_ids ? data.used_entry_ids.length : 0;
          askStatus.textContent = "";
          answerMeta.textContent = usedCount
            ? `This answer is based on ${usedCount} past entr${usedCount === 1 ? "y" : "ies"}.`
            : "";
          if (usedCount) {
            answerMeta.classList.remove("hidden");
          }
          if (data.used_entries && data.used_entries.length) {
            renderUsedEntries(data.used_entries);
          }
        } catch (err) {
          askStatus.textContent = `Error: ${err.message}`;
        } finally {
          askBtn.disabled = false;
        }
      }

      askBtn.addEventListener("click", askQuestion);
      chatSendBtn.addEventListener("click", sendConversationMessage);

      // Initial state
      setActiveTab("capture");
    </script>
  </body>
</html>
